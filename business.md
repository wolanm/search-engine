## 架构
gateway->mq->正排、倒排、向量

## 业务

### 基于倒排和向量实现多路召回
#### *成果*

#### *设计: 如何优化效率? 通过文档大小->构建速度来量化索引构建的效率(不太可行)，从bitmap存储以及压缩存储着手*

##### 依赖BM25召回

BM25 公式:

```shell
Score(D, Q) = Σ [ IDF(q_i) * ( TF(q_i, D) * (k1 + 1) ) / ( TF(q_i, D) + k1 * (1 - b + b * |D| / avgdl) ) ]
```
* IDF(q_i) - 逆文档频率项 IDF 衡量一个词的普遍重要性。一个词在所有文档中出现的越频繁，其 IDF 值越低。
IDF(q_i) = log( 1 + (N - n(q_i) + 0.5) / (n(q_i) + 0.5) )
* N：文档集合中的总文档数。
* n(q_i)：包含词项 q_i 的文档数量。
* TF(q_i, D)：词项 q_i 在文档 D 中出现的次数。
* |D|：文档 D 的长度（通常用词数表示）。 
* avgdl：整个文档集合中所有文档的平均长度。 
* k1：一个可调参数，控制词频的饱和速率。 k1 越大，饱和越慢，词频的影响越大（通常取值在 1.2 到 2.0 之间）。 k1 = 0 意味着完全忽略词频。 
* b：另一个可调参数，控制文档长度归一化的强度。
b 在 0 到 1 之间。
b = 1 表示 fully normalizing（完全进行长度归一化）。
b = 0 表示完全不进行长度归一化。

搜索优化: 构建索引时提前计算公式所需参数

##### boltdb 存储倒排索引及统计信息

##### 正排索引采用 mysql

##### 多路召回后的精细重排？了解一下

#### *qps*

### 索引构建通过消息队列解耦
用法: 收到索引构建请求后，将文档信息发送到 rabbitmq，倒排索引和向量索引同时消费

消息处理的幂等性: 索引服务(倒排、向量)分别通过 redis 缓存 message_id 实现消费的幂等性
message_id 如何设计? uuid + 时间戳

可靠性保证：通过 rabbitmq 的消息确认机制，确保消息被成功处理后才从队列中移除，防止消息丢失。
考虑到文件上传本身就不是一个频繁的操作，不会导致消息堆积

### 热查询缓存 -- 分布式锁保证?
单用户: 最近的10条搜索记录
总搜索: 最高频的前30次搜索
*成果*

### 查询的分布式锁?

