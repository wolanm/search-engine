[toc]

## 架构
gateway->mq->正排、倒排、向量
k8s部署?

## 业务

### 基于倒排和向量实现多路召回
#### *成果*

#### *设计: 如何优化效率? 通过文档大小->构建速度来量化索引构建的效率(不太可行)*

##### 依赖BM25召回

BM25 公式:

```shell
Score(D, Q) = Σ [ IDF(q_i) * ( TF(q_i, D) * (k1 + 1) ) / ( TF(q_i, D) + k1 * (1 - b + b * |D| / avgdl) ) ]
```
* IDF(q_i) - 逆文档频率项 IDF 衡量一个词的普遍重要性。一个词在所有文档中出现的越频繁，其 IDF 值越低。
IDF(q_i) = log( 1 + (N - n(q_i) + 0.5) / (n(q_i) + 0.5) )
* N：文档集合中的总文档数。
* n(q_i)：包含词项 q_i 的文档数量。
* TF(q_i, D)：词项 q_i 在文档 D 中出现的次数。
* |D|：文档 D 的长度（通常用词数表示）。 
* avgdl：整个文档集合中所有文档的平均长度。 
* k1：一个可调参数，控制词频的饱和速率。 k1 越大，饱和越慢，词频的影响越大（通常取值在 1.2 到 2.0 之间）。 k1 = 0 意味着完全忽略词频。 
* b：另一个可调参数，控制文档长度归一化的强度。
b 在 0 到 1 之间。
b = 1 表示 fully normalizing（完全进行长度归一化）。
b = 0 表示完全不进行长度归一化。

搜索优化: 构建索引时提前计算公式所需参数

##### mysql 存储倒排索引及预计算信息，加快召回速度

#####  召回后的融合和精细排序
倒排和向量融合: 0.6 * 倒排score + 0.4 * 向量score，倒排权重更多的原因:
1. 知识库文档内容结构化程度高，BM25匹配效果好
2. 为了保障覆盖率

最终输入大模型的文档为 8 篇(权重最高的前 8 篇)


##### 正排索引采用 mysql(具体结构?)

### 索引构建通过消息队列解耦
用法: 收到索引构建请求后，将文档信息发送到 rabbitmq，倒排索引和向量索引同时消费

消息处理的幂等性: 索引服务(倒排、向量)分别通过 redis 缓存 message_id 实现消费的幂等性
message_id 如何设计? uuid + 时间戳

可靠性保证：通过 rabbitmq 的消息确认机制，确保消息被成功处理后才从队列中移除，防止消息丢失。
考虑到文件上传本身就不是一个频繁的操作，不会导致消息堆积

### 热查询缓存(redis 集群)
多副本搜索服务，缓存机制分为本地和分布式redis缓存

文档更新时如何让所有缓存(本地、redis)失效? 消息队列通知

查询语句差一个字可能就会导致查询缓存失效，这种情况如何处理？ 根据语义相似性(向量相似度)处理，相似度 > 0.85 则认为相同

缓存每个用户最近的10条搜索记录，通过 redis 的 List 实现，key 为 recent_query:{user_id}(需要注意去重)

统计hot30: 通过 redis 的 zset 实现，每次搜索时，对搜索词的分数加 1，并重新排序，每天对搜索的热度减5%。实际会缓存300条记录，以进行热度更替 

三层缓存:
* L1: hot30 衰减因子 0.95，每 24h 进行一次衰减
* L2: hot300 衰减因子 0.9，每 12h 进行一次衰减
* L3: 其他 衰减因子 0.8 每 1h 进行一次衰减
当分数 < 0.8 时，清除缓存

缓存的加锁：每一级缓存一把锁
1. 查询时的加锁:先从本地缓存获取，获取成功则直接加锁(对应层级的锁)，按照 L1->L2->L3 的顺序查询缓存，依次先加读锁，如果 L1 获取到了，则加 L1 的写锁，更新 query 的 score，依次类推。
如果三层缓存都没查到，则执行搜索，同时写入L3缓存，如果搜索无结果，则考虑设置缓存内容为空值，避免缓存击穿
2. 衰减时的加锁: 对单一层级加锁，先衰减，再考虑缓存层级的迁移
3. 缓存层级迁移时的加锁: 对迁移涉及的缓存层级加锁

噪声排除: 如test、测试、111 等


如何避免缓存击穿、穿透、雪崩?

倒排的缓存?

缓存分布式锁的实现?

*成果*

#### *qps*
3000 销售人员，人均每天30-50次查询，一天 3000 * 50 = 150000，按照一天工作八小时来计算

| QPS 类型         | 数值  | 用途               |
| :--------------- | :---- | :----------------- |
| **平均 QPS**     | 5-6   | 资源预算和成本计算 |
| **典型峰值 QPS** | 10-15 | 日常容量规划       |
| **安全峰值 QPS** | 20-25 | 弹性扩容阈值       |
| **极端峰值 QPS** | 40+   | 系统极限测试       |


### 查询的分布式锁?
redis setnx + lua

### 接口限流、熔断、降级?