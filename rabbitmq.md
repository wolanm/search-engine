[toc]

## 八股

### rabbitmq 工作模式
1. simple 模式:
   * 消息产生消息，将消息放入队列，只有一个消费者监听这个队列。
   * 消息的消费者(consumer) 监听 消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除。
2. work queue 模式:
   * 生产者将消息发送到队列，多个消费者监听同一个队列，队列中的消息被多个消费者竞争消费，谁先抢到谁就消费掉，消费掉后消息从队列中删除。
3. publish/subscribe 模式:
    * 生产者将消息发送到交换机(exchange)，交换机将消息路由到绑定的队列中，多个消费者监听不同的队列，消费者各自消费自己的队列中的消息。
4. routing 模式:
    * 生产者将消息发送到交换机(exchange)，交换机根据路由键(routing key)将消息路由到绑定的队列中，多个消费者监听不同的队列，消费者各自消费自己的队列中的消息。
5. topics 模式:
    * 生产者将消息发送到交换机(exchange)，交换机根据主题(topic，支持模糊匹配)将消息路由到绑定的队列中，多个消费者监听不同的队列，消费者各自消费自己的队列中的消息。

#### 注意
* 绑定交换机的队列，获取不到队列绑定前发送到交换机的消息
* 如果一个队列更换了交换机的绑定，那么之后消费者监听这个队列时，会收到更换绑定前的消息

### 消息可靠性怎么保证
消息丢失场景及解决方案:
1. 生产者消息丢失
   * 发送消息过程中由于网络问题消息丢失
   * 代码问题导致消息未发送成功
解决方案:
   1. 生产者发送消息时开启消息确认机制(confirm mode)，确保消息发送到 broker 成功
   2. 开启事务，不推荐，这样只能串行发送消息，存在队头阻塞问题
2. server 丢失消息
   * 消息没有持久化，server 宕机导致消息丢失
解决方案:
    1. 将消息和队列设置为持久化
    2. 消息回退，开启 mandatory 参数，当消息无法路由到队列时，broker 会将消息返回给生产者，生产者可以重新发送消息。如果不清楚如何处理这些消息，可以备份一个交换机，将无法路由的消息发送到备份交换机绑定的队列中保存
3. 消费者丢失消息:
   * 消费端接收到相关消息之后，消费端还没来得及处理消息，消费端机器就宕机了
   * 处理消息存在异常
解决方案:
   1. 消费者开启手动确认模式，处理完消息后再发送 ack 确认消息已被消费
   2. 消息重试机制，消费者处理消息失败时，可以将消息重新放回队列，或者发送到专门的重试队列中，进行延时重试
   3. 死信队列，设置消息的最大重试次数，超过次数后将消息发送到死信队列中，进行人工干预或特殊处理


### 消息幂等性怎么保证
在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列。

### 如何实现消息的顺序消费
思路: 单一队列 + 单线程消费(单一消费者)
1. 全局串行: 整个系统只用一个队列，所有消息都进入这个队列，消费者单线程消费
2. 局部串行: 通过消息分组或一致性哈希，将需要保证顺序的一组消息路由到同一个队列，消费者单线程消费该队列

### 死信消息什么情况产生，如何处理
死信消息产生场景:
1. 消息被拒绝(basic.reject/basic.nack)且 requeue=false
2. 消息过期(ttl)
3. 队列达到最大长度

处理死信消息:
消息被拒绝可以进行重试，指数退避 + 最大重试，超过阈值后进行持久化，转人工处理
消息过期一般是用于实现延迟队列
队列达到最大长度一般是消费者处理能力不足导致消息积压，可以考虑扩容队列或者增加消费者

### 死信队列满了怎么办?
扩容死信队列，增加消费者消费死信队列中的消息，或者将死信消息持久化到数据库中，进行人工处理

### 延迟队列的实现
通过死信队列 + TTL 实现延迟队列


### 消息堆积如何处理
应急处理:
1. 动态扩容消费者
2. 消费者批量消费
3. 临时启动多消费者示例
4. 消息降级，非核心业务暂不处理

长期解决方案
1. 消息分片
2. 监控与弹性扩缩容
