[toc]

## 八股

### rabbitmq 工作模式
1. simple 模式:
   * 消息产生消息，将消息放入队列，只有一个消费者监听这个队列。
   * 消息的消费者(consumer) 监听 消息队列，如果队列中有消息，就消费掉，消息被拿走后，自动从队列中删除。
2. work queue 模式:
   * 生产者将消息发送到队列，多个消费者监听同一个队列，队列中的消息被多个消费者竞争消费，谁先抢到谁就消费掉，消费掉后消息从队列中删除。
3. publish/subscribe 模式:
    * 生产者将消息发送到交换机(exchange)，交换机将消息路由到绑定的队列中，多个消费者监听不同的队列，消费者各自消费自己的队列中的消息。
4. routing 模式:
    * 生产者将消息发送到交换机(exchange)，交换机根据路由键(routing key)将消息路由到绑定的队列中，多个消费者监听不同的队列，消费者各自消费自己的队列中的消息。
5. topics 模式:
    * 生产者将消息发送到交换机(exchange)，交换机根据主题(topic，支持模糊匹配)将消息路由到绑定的队列中，多个消费者监听不同的队列，消费者各自消费自己的队列中的消息。

#### 注意
* 绑定交换机的队列，获取不到队列绑定前发送到交换机的消息
* 如果一个队列更换了交换机的绑定，那么之后消费者监听这个队列时，会收到更换绑定前的消息

### 消息可靠性怎么保证
消息丢失场景:
1. 生产者消息丢失:  
2. server 丢失消息:  
3. 消费者丢失消息: 

### 消息幂等性怎么保证

### 如何实现消息的顺序消费
思路: 单一队列 + 单线程消费(单一消费者)
1. 全局串行: 整个系统只用一个队列，所有消息都进入这个队列，消费者单线程消费
2. 局部串行: 通过消息分组或一致性哈希，将需要保证顺序的一组消息路由到同一个队列，消费者单线程消费该队列

### 死信消息什么情况产生，如何处理
死信消息产生场景:
1. 消息被拒绝(basic.reject/basic.nack)且 requeue=false
2. 消息过期(ttl)
3. 队列达到最大长度

处理死信消息:


### 消息堆积如何处理

